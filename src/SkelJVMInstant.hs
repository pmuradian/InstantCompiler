module SkelJVMInstant where

-- Haskell module generated by the BNF converter

import System.IO ( stdin, hGetContents )
import AbsInstant
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

concatArray :: [String] -> String
concatArray (x:xs) = x ++ concatArray xs
concatArray [] = "\n"

findIndex :: Integer -> String -> [String] -> Integer
findIndex start character (x:xs) = if x == character then start else findIndex (start + 1) character xs
findIndex start character [] = start

decrementStackSize :: Context -> Context
decrementStackSize ctx = Context (stackSize ctx) ((currentStackSize ctx) - 1) (locals ctx) (names ctx)

incrementStackSize :: Context -> Context
incrementStackSize ctx = do
  let incremented = (currentStackSize ctx) + 1
  if stackSize ctx < incremented then Context incremented incremented (locals ctx) (names ctx)
  else Context (stackSize ctx) incremented (locals ctx) (names ctx)

transProgram :: Program -> Context -> (String, Context)
transProgram x context = case x of
  Prog stmts -> do 
    let first = head stmts
    let output = transStmt first context
    let out = fst output
    let ctx = snd output
    let t = tail stmts
    if t == [] then (out, ctx)
    else do
      let p = Prog t
      let result = transProgram p ctx
      (out ++ fst result, snd result)

transStmt :: Stmt -> Context -> (String, Context)
transStmt x c = case x of
  SAss ident exp -> do
      let id = transIdent ident
      let index = findIndex 0 id (names c)
      let n = (names c) ++ [id]
      let newContext = Context (stackSize c) (currentStackSize c) (locals c) n
      let res = transExp exp newContext
      let e = (fst res) ++ "    istore " ++ show index ++ "\n"
      (e, decrementStackSize(snd res))
  SExp exp -> transExp exp c

transIdent :: Ident -> String
transIdent x = case x of
  Ident string -> string

transExp :: Exp -> Context -> (String, Context)
transExp x c = case x of
  ExpAdd exp1 exp2 -> transJVMExpression exp1 exp2 "iadd" c
  ExpSub exp1 exp2 -> transJVMExpression exp1 exp2 "isub" c
  ExpMul exp1 exp2 -> transJVMExpression exp1 exp2 "imul" c
  ExpDiv exp1 exp2 -> transJVMExpression exp1 exp2 "idiv" c
  ExpLit integer -> if integer <= 5 then ("    iconst_" ++ show integer ++ "\n", incrementStackSize c) else ("    bipush " ++ show integer ++ "\n", incrementStackSize c)
  ExpVar ident -> do 
    let id = transIdent ident
    let index = findIndex 0 id (names c)
    ("    iload " ++ show index ++ "\n", incrementStackSize c)


transJVMExpression :: Exp -> Exp -> String -> Context -> (String, Context)
transJVMExpression exp1 exp2 operation c = do
  let l = transExp exp1 c
  let c1 = snd l
  let r = transExp exp2 c1
  let res = (fst l) ++ (fst r)
  let c2 = snd r
  let finalContext = decrementStackSize c2
  (res ++ "    " ++ operation ++ "\n", finalContext)