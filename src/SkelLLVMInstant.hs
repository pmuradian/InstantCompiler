module SkelLLVMInstant where

-- Haskell module generated by the BNF converter

import System.IO ( stdin, hGetContents )
import AbsInstant

concatLLVMArray :: [String] -> String
concatLLVMArray (x:xs) = x ++ concatLLVMArray xs
concatLLVMArray [] = "\n"

setVarName :: LLVMContext -> String -> LLVMContext
setVarName ctx v = LLVMContext v (localsCount ctx) (vars ctx)

incrementLocalsCount :: LLVMContext -> LLVMContext
incrementLocalsCount ctx = LLVMContext (varName ctx) ((localsCount ctx) + 1) (vars ctx)

transLLVMProgram :: Program -> LLVMContext -> String
transLLVMProgram x context = case x of
  Prog stmts -> do 
    let first = head stmts
    let output = tranLLVMsStmt first context
    let out = fst output
    let ctx = snd output
    let t = tail stmts
    if t == [] then out
    else do
      let p = Prog t
      let asdf = transLLVMProgram p ctx
      out ++ asdf

tranLLVMsStmt :: Stmt -> LLVMContext -> (String, LLVMContext)
tranLLVMsStmt x c = case x of
  SAss ident exp -> do
      let id = transLLVMIdent ident
      let index = 0
      let n = (vars c) ++ [id]
      let newLLVMContext = LLVMContext (varName c) (localsCount c) n
      let res = transLLVMExp exp newLLVMContext
      let alloc = "    " ++ id ++ " = alloca i32\n"
      let prev = fst res
      let e = alloc ++ "    store i32 " ++ prev ++ ", i32* " ++ id ++ "\n"
      (e, snd res)
  SExp exp -> transLLVMExp exp c

transLLVMIdent :: Ident -> String
transLLVMIdent x = case x of
  Ident string -> "%loc_" ++ string

transLLVMExp :: Exp -> LLVMContext -> (String, LLVMContext)
transLLVMExp x c = case x of
  ExpAdd exp1 exp2 -> transLLVMExpression exp1 exp2 "add" c
  ExpSub exp1 exp2 -> transLLVMExpression exp1 exp2 "sub" c
  ExpMul exp1 exp2 -> transLLVMExpression exp1 exp2 "mul" c
  ExpDiv exp1 exp2 -> transLLVMExpression exp1 exp2 "sdiv" c
  ExpLit integer -> (show integer, c)
  ExpVar ident -> do 
    let id = transLLVMIdent ident
    let index = localsCount c
    let ctx = (setVarName (incrementLocalsCount c) ("%tmp_" ++ show index))
    ("    %tmp_" ++ show index ++ " = load i32, i32* " ++ id ++ "\n", ctx)

transLLVMExpression :: Exp -> Exp -> String -> LLVMContext -> (String, LLVMContext)
transLLVMExpression exp1 exp2 operation c = do
  let l = transLLVMExp exp1 c
  let c1 = snd l
  let id1 = varName c1
  let r = transLLVMExp exp2 c1
  let res = (fst l) ++ (fst r)
  let c2 = snd r
  let id2 = varName c2
  let id3 = "%tmp_" ++ show(localsCount c2)
  let finalLLVMContext = setVarName c2 id3
  (res ++ "    " ++ id3 ++ " = " ++ operation ++ " i32 " ++ id1 ++ ", " ++ id2 ++ "\n", incrementLocalsCount finalLLVMContext)