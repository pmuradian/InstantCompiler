module SkelLLVMInstant where

-- Haskell module generated by the BNF converter

import System.IO ( stdin, hGetContents )
import AbsInstant

findIndex :: Integer -> String -> [String] -> Integer
findIndex start character (x:xs) = if x == character then start else findIndex (start + 1) character xs
findIndex start character [] = 0

setVarName :: LLVMContext -> String -> LLVMContext
setVarName ctx v = LLVMContext v (localsCount ctx) (vars ctx)

incrementLocalsCount :: LLVMContext -> LLVMContext
incrementLocalsCount ctx = LLVMContext (varName ctx) ((localsCount ctx) + 1) (vars ctx)

transLLVMProgram :: Program -> LLVMContext -> String
transLLVMProgram x context = case x of
  Prog stmts -> do 
    let first = head stmts
    let output = tranLLVMsStmt first context
    let out = fst output
    let ctx = snd output
    let t = tail stmts
    if t == [] then out
    else do
      let p = Prog t
      let asdf = transLLVMProgram p ctx
      out ++ asdf

tranLLVMsStmt :: Stmt -> LLVMContext -> (String, LLVMContext)
tranLLVMsStmt x c = case x of
  SAss ident exp -> do
      let id = transLLVMIdent ident
      let index = 0
      let alloc = if findIndex 0 id (vars c) == 0 then "    " ++ id ++ " = alloca i32\n" else ""
      let n = (vars c) ++ [id]
      let newLLVMContext = LLVMContext (varName c) (localsCount c) n
      let res = transLLVMExp exp newLLVMContext
      let prev = fst res
      let temp = varName (snd res)
      let e = alloc ++ prev ++ "    store i32 " ++ temp ++ ", i32* " ++ id ++ "\n"
      (e, snd res)
  SExp exp -> case exp of
    ExpLit int -> do 
      let res = transLLVMExp exp c
      let cont = snd res
      let unsedName = "%unused_" ++ show(localsCount cont)
      let result = "    " ++ unsedName ++ " = alloca i32\n"
      let ret = result ++ "    store i32 " ++ varName cont ++ ", i32* " ++ unsedName ++ "\n"
      (ret, incrementLocalsCount cont)
    otherwise -> transLLVMExp exp c


transLLVMIdent :: Ident -> String
transLLVMIdent x = case x of
  Ident string -> "%loc_" ++ string

transLLVMExp :: Exp -> LLVMContext -> (String, LLVMContext)
transLLVMExp x c = case x of
  ExpAdd exp1 exp2 -> transLLVMExpression exp1 exp2 "add" c
  ExpSub exp1 exp2 -> transLLVMExpression exp1 exp2 "sub" c
  ExpMul exp1 exp2 -> transLLVMExpression exp1 exp2 "mul" c
  ExpDiv exp1 exp2 -> transLLVMExpression exp1 exp2 "sdiv" c
  ExpLit integer -> do
    let id = show integer
    ("", setVarName c id)
  ExpVar ident -> do 
    let id = transLLVMIdent ident
    let index = localsCount c
    let ctx = (setVarName (incrementLocalsCount c) ("%tmp_" ++ show index))
    ("    %tmp_" ++ show index ++ " = load i32, i32* " ++ id ++ "\n", ctx)

transLLVMExpression :: Exp -> Exp -> String -> LLVMContext -> (String, LLVMContext)
transLLVMExpression exp1 exp2 operation c = do
  let l = transLLVMExp exp1 c
  let c1 = snd l
  let id1 = varName c1
  let r = transLLVMExp exp2 c1
  let res = (fst l) ++ (fst r)
  let c2 = snd r
  let id2 = varName c2
  let id3 = "%tmp_" ++ show(localsCount c2)
  let finalLLVMContext = setVarName c2 id3
  (res ++ "    " ++ id3 ++ " = " ++ operation ++ " i32 " ++ id1 ++ ", " ++ id2 ++ "\n", incrementLocalsCount finalLLVMContext)