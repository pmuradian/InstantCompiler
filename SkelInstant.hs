module SkelInstant where

-- Haskell module generated by the BNF converter

import System.IO ( stdin, hGetContents )
import AbsInstant
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

concatArray :: [String] -> String
concatArray (x:xs) = x ++ concatArray xs
concatArray [] = "\n"

findIndex :: Integer -> String -> [String] -> Integer
findIndex start character (x:xs) = if x == character then start else findIndex (start + 1) character xs
findIndex start character [] = start

decrementStackSize :: Context -> Context
decrementStackSize ctx = Context ((stackSize ctx) - 1) (locals ctx) (names ctx)

incrementStackSize :: Context -> Context
incrementStackSize ctx = Context ((stackSize ctx) + 1) (locals ctx) (names ctx)

transProgram :: Program -> Context -> String
transProgram x context = case x of
  Prog stmts -> do 
    let first = head stmts
    let output = transStmt first context
    let out = fst output
    let ctx = snd output
    let t = tail stmts
    if t == [] then out
    else do
      let p = Prog t
      let asdf = transProgram p ctx
      out ++ asdf

transStmt :: Stmt -> Context -> (String, Context)
transStmt x c = case x of
  SAss ident exp -> do
      let id = transIdent ident
      let index = findIndex 0 id (names c)
      let n = (names c) ++ [id]
      let newContext = Context 0 0 n
      let e = (transExp exp c) ++ "istore " ++ show index ++ "\n"
      (e, newContext)
  SExp exp -> (transExp exp c, c)

transIdent :: Ident -> String
transIdent x = case x of
  Ident string -> string

transExp :: Exp -> Context -> String
transExp x c = case x of
  ExpAdd exp1 exp2 -> do
    (transExp exp1 c) ++ (transExp exp2 c) ++ "iadd\n"
    decrementStackSize c
  ExpSub exp1 exp2 -> do
    (transExp exp2 c) ++ (transExp exp1 c) ++ "isub\n"
    decrementStackSize c
  ExpMul exp1 exp2 -> do
    (transExp exp1 c) ++ (transExp exp2 c) ++ "imul\n"
    decrementStackSize c
  ExpDiv exp1 exp2 -> do
    (transExp exp2 c) ++ (transExp exp1 c) ++ "idiv\n"
    decrementStackSize c
  ExpLit integer -> do
    incrementStackSize c
    "iconst " ++ show integer ++ "\n"
  ExpVar ident -> do 
    let id = transIdent ident
    let index = findIndex 0 id (names c)
    incrementStackSize c
    "iload " ++ (show index) ++ "\n"
