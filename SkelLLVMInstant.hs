module SkelLLVMInstant where

-- Haskell module generated by the BNF converter

import System.IO ( stdin, hGetContents )
import AbsInstant

concatLLVMArray :: [String] -> String
concatLLVMArray (x:xs) = x ++ concatLLVMArray xs
concatLLVMArray [] = "\n"

-- findLLVMIndex :: Integer -> String -> [String] -> Integer
-- findLLVMIndex start character (x:xs) = if x == character then start else findLLVMIndex (start + 1) character xs
-- findLLVMIndex start character [] = start

-- decrementLLVMStackSize :: LLVMContext -> LLVMContext
-- decrementLLVMStackSize ctx = LLVMContext (stackSize ctx) ((currentStackSize ctx) - 1) (locals ctx) (names ctx)

setVarName :: LLVMContext -> String -> LLVMContext
setVarName ctx v = LLVMContext v (line ctx) (localsCount ctx) (vars ctx)

setLine :: LLVMContext -> String -> LLVMContext
setLine ctx v = LLVMContext (varName ctx) v (localsCount ctx) (vars ctx)

incrementLocalsCount :: LLVMContext -> LLVMContext
incrementLocalsCount ctx = LLVMContext (varName ctx) (line ctx) ((localsCount ctx) + 1) (vars ctx)

transLLVMProgram :: Program -> LLVMContext -> String
transLLVMProgram x context = case x of
  Prog stmts -> do 
    let first = head stmts
    let output = tranLLVMsStmt first context
    let out = fst output
    let ctx = snd output
    let t = tail stmts
    if t == [] then out
    else do
      let p = Prog t
      let asdf = transLLVMProgram p ctx
      out ++ asdf

tranLLVMsStmt :: Stmt -> LLVMContext -> (String, LLVMContext)
tranLLVMsStmt x c = case x of
  SAss ident exp -> do
      let id = transLLVMIdent ident
      let index = 0
      let n = (vars c) ++ [id]
      let newLLVMContext = LLVMContext (varName c) (line c) (localsCount c) n
      let res = transLLVMExp exp newLLVMContext
      let alloc = id ++ " = alloca i32\n"
      let prev = fst res
      let e = alloc ++ "store i32 " ++ prev ++ ", i32* " ++ id ++ "\n"
      (e, snd res)
  SExp exp -> transLLVMExp exp c

transLLVMIdent :: Ident -> String
transLLVMIdent x = case x of
  Ident string -> "%loc_" ++ string

transLLVMExp :: Exp -> LLVMContext -> (String, LLVMContext)
transLLVMExp x c = case x of
  ExpAdd exp1 exp2 -> do
    let l = transLLVMExp exp1 c
    let c1 = snd l
    let id1 = varName c1
    let r = transLLVMExp exp2 c1
    let res = (fst l) ++ (fst r)
    let c2 = snd r
    let id2 = varName c2
    let id3 = "%tmp_" ++ show(localsCount c2)
    let finalLLVMContext = setVarName c2 id3
    (res ++ id3 ++ " = add i32 " ++ id1 ++ ", " ++ id2 ++ "\n", incrementLocalsCount finalLLVMContext)
  ExpSub exp1 exp2 -> do
    let l = transLLVMExp exp1 c
    let c1 = snd l
    let id1 = varName c1
    let r = transLLVMExp exp2 c1
    let res = (fst l) ++ (fst r)
    let c2 = snd r
    let id2 = varName c2
    let id3 = "%tmp_" ++ show(localsCount c2)
    let finalLLVMContext = setVarName c2 id3
    (res ++ id3 ++ " = sub i32 " ++ id1 ++ ", " ++ id2 ++ "\n", incrementLocalsCount finalLLVMContext)
  ExpMul exp1 exp2 -> do
    let l = transLLVMExp exp1 c
    let c1 = snd l
    let id1 = varName c1
    let r = transLLVMExp exp2 c1
    let res = (fst l) ++ (fst r)
    let c2 = snd r
    let id2 = varName c2
    let id3 = "%tmp_" ++ show(localsCount c2)
    let finalLLVMContext = setVarName c2 id3
    (res ++ id3 ++ " = mul i32 " ++ id1 ++ ", " ++ id2 ++ "\n", incrementLocalsCount finalLLVMContext)
  ExpDiv exp1 exp2 -> do
    let l = transLLVMExp exp1 c
    let c1 = snd l
    let id1 = varName c1
    let r = transLLVMExp exp2 c1
    let res = (fst l) ++ (fst r)
    let c2 = snd r
    let id2 = varName c2
    let id3 = "%tmp_" ++ show(localsCount c2)
    let finalLLVMContext = setVarName c2 id3
    (res ++ id3 ++ " = sdiv i32 " ++ id1 ++ ", " ++ id2 ++ "\n", incrementLocalsCount finalLLVMContext)
  ExpLit integer -> (show integer, c)
  ExpVar ident -> do 
    let id = transLLVMIdent ident
    let index = localsCount c
    let ctx = (setVarName (incrementLocalsCount c) ("%tmp_" ++ show index))
    ("%tmp_" ++ show index ++ " = load i32* " ++ id ++ "\n", ctx)
